# frozen_string_literal: true

require "zip"
require "open3"
require "pathname"

module WhatsOpt
  class CodeGenerator
    PYTHON = APP_CONFIG["python_cmd"] || "python"
    DEFAULT_DOE_DRIVER = :smt_doe_lhs
    DEFAULT_OPTIMIZATION_DRIVER = :scipy_optimizer_slsqp

    attr_accessor :genfiles, :prefix, :server_host, :server_port

    def initialize(mda, pkg_format: false, server_host: nil, server_port: 31400)
      @prefix = "code"
      @comment_delimiters = { begin: '"""', end: '"""' }
      @mda = mda
      @impl = mda.impl
      @template_dir = File.join(File.dirname(__FILE__), "templates")
      @genfiles = []
      @server_module = "server"
      @egmdo_module = "egmdo"
      @server_host = "localhost"
      @server_host = server_host
      @remote = !server_host.nil?
      @server_port = server_port
      # TODO: Should be independent from OpenMDAO impl
      # (should be something like Python impl) but at the moment
      # package format (@pkg_prefix) is only implemented (used) with
      # OpenMDAO Python framework
      @pkg_prefix = pkg_format ? "#{@mda.openmdao_impl&.top_packagename}." : ""
      @generator = self
    end

    def package_dir?
      !@pkg_prefix.blank? && @mda.is_root?
    end

    # options: with_run: true, with_server: false, with_runops: true, user_agent: nil, sqlite_filename: nil
    def generate(options = {})
      zip_filename = nil
      stringio = nil
      @genfiles = []
      Dir.mktmpdir("#{prefix}_#{@mda.impl.basename}_") do |dir|
        # dir='/tmp'
        zip_rootpath = Pathname.new(dir)
        zip_filename = File.basename(dir) + ".zip"
        _generate_code(dir, options)
        _format_code(dir)
        stringio = Zip::OutputStream.write_buffer do |zio|
          @genfiles.each do |filename|
            entry = Pathname.new(filename).relative_path_from(zip_rootpath)
            zio.put_next_entry(entry)
            File.open(filename) do |f|
              zio.write f.read
            end
          end
        end
      end
      stringio.rewind
      return stringio.read, zip_filename
    end

    def render_partial(file)
      ERB.new(File.read(File.join(@template_dir, file))).result(binding)
    end

    def _generate(filename, template_filename, gendir, no_comment: false)
      template = File.join(@template_dir, template_filename)
      Rails.logger.info "Creating #{filename} from #{File.basename(template)} in #{gendir}"
      filepath = File.join(gendir, filename) if gendir
      result = ""
      result += _comment_header(filepath) unless no_comment
      result += _run_template(template)
      fh = File.open(filepath, "w:utf-8")
      fh.print result
      fh.close
      @genfiles << filepath if !@genfiles.include?(filepath)
      filepath
    end

    def _run_template(name)
      erb = ERB.new(File.open(name, "rb:utf-8").read, trim_mode: "-")
      erb.result(binding)
    end

    def _comment_header(filepath)
      <<HEADER
#{@comment_delimiters[:begin]}
  #{File.basename(filepath)} generated by WhatsOpt #{WhatsOpt::Version::VERSION}
#{@comment_delimiters[:end]}
HEADER
    end

    def _format_code(dir)
      # ["black", "ruff"].each do |formatter|
      ["ruff"].each do |formatter|
        cmd = if formatter == "ruff"
          "#{PYTHON} -m #{formatter} format --line-length 100 #{dir}"
        else
          "#{PYTHON} -m #{formatter} --line-length 100 #{dir}"
        end
        Rails.logger.info cmd
        stdouterr, status = Open3.capture2e(cmd)
        unless status.success?
          Rails.logger.warn "#{formatter.capitalize} formatting failed!"
          Rails.logger.warn "#{stdouterr}"
        end
      end
    end
  end
end
