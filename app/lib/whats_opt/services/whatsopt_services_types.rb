#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'

module WhatsOpt
  module Services
    module SurrogateKind
      SMT_KRIGING = 0
      SMT_KPLS = 1
      SMT_KPLSK = 2
      SMT_LS = 3
      SMT_QP = 4
      OPENTURNS_PCE = 5
      VALUE_MAP = {0 => "SMT_KRIGING", 1 => "SMT_KPLS", 2 => "SMT_KPLSK", 3 => "SMT_LS", 4 => "SMT_QP", 5 => "OPENTURNS_PCE"}
      VALID_VALUES = Set.new([SMT_KRIGING, SMT_KPLS, SMT_KPLSK, SMT_LS, SMT_QP, OPENTURNS_PCE]).freeze
    end

    module OptimizerKind
      SEGOMOE = 0
      SEGMOOMOE = 1
      VALUE_MAP = {0 => "SEGOMOE", 1 => "SEGMOOMOE"}
      VALID_VALUES = Set.new([SEGOMOE, SEGMOOMOE]).freeze
    end

    module ConstraintType
      LESS = 0
      EQUAL = 1
      GREATER = 2
      VALUE_MAP = {0 => "LESS", 1 => "EQUAL", 2 => "GREATER"}
      VALID_VALUES = Set.new([LESS, EQUAL, GREATER]).freeze
    end

    module Type
      FLOAT = 0
      INT = 1
      ORD = 2
      ENUM = 3
      VALUE_MAP = {0 => "FLOAT", 1 => "INT", 2 => "ORD", 3 => "ENUM"}
      VALID_VALUES = Set.new([FLOAT, INT, ORD, ENUM]).freeze
    end

    module HsicThresholding
      ZERO = 0
      COND = 1
      IND = 2
      VALUE_MAP = {0 => "ZERO", 1 => "COND", 2 => "IND"}
      VALID_VALUES = Set.new([ZERO, COND, IND]).freeze
    end

    class OptionValue < ::Thrift::Union; end

    class SurrogateException < ::Thrift::Exception; end

    class OptimizerException < ::Thrift::Exception; end

    class SurrogateQualification; end

    class SobolIndices; end

    class Distribution; end

    class OptimizerResult; end

    class ConstraintSpec; end

    class Flimits; end

    class Ilimits; end

    class Xlimits < ::Thrift::Union; end

    class Xtype; end

    class HsicAnalysis; end

    class OptionValue < ::Thrift::Union
      include ::Thrift::Struct_Union
      class << self
        def integer(val)
          OptionValue.new(:integer, val)
        end

        def number(val)
          OptionValue.new(:number, val)
        end

        def vector(val)
          OptionValue.new(:vector, val)
        end

        def matrix(val)
          OptionValue.new(:matrix, val)
        end

        def str(val)
          OptionValue.new(:str, val)
        end

        def boolean(val)
          OptionValue.new(:boolean, val)
        end
      end

      INTEGER = 1
      NUMBER = 2
      VECTOR = 3
      MATRIX = 4
      STR = 5
      BOOLEAN = 6

      FIELDS = {
        INTEGER => {:type => ::Thrift::Types::I64, :name => 'integer', :optional => true},
        NUMBER => {:type => ::Thrift::Types::DOUBLE, :name => 'number', :optional => true},
        VECTOR => {:type => ::Thrift::Types::LIST, :name => 'vector', :element => {:type => ::Thrift::Types::DOUBLE}, :optional => true},
        MATRIX => {:type => ::Thrift::Types::LIST, :name => 'matrix', :element => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::DOUBLE}}, :optional => true},
        STR => {:type => ::Thrift::Types::STRING, :name => 'str', :optional => true},
        BOOLEAN => {:type => ::Thrift::Types::BOOL, :name => 'boolean', :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
      end

      ::Thrift::Union.generate_accessors self
    end

    class SurrogateException < ::Thrift::Exception
      include ::Thrift::Struct, ::Thrift::Struct_Union
      def initialize(message=nil)
        super()
        self.msg = message
      end

      def message; msg end

      MSG = 1

      FIELDS = {
        MSG => {:type => ::Thrift::Types::STRING, :name => 'msg'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class OptimizerException < ::Thrift::Exception
      include ::Thrift::Struct, ::Thrift::Struct_Union
      def initialize(message=nil)
        super()
        self.msg = message
      end

      def message; msg end

      MSG = 1

      FIELDS = {
        MSG => {:type => ::Thrift::Types::STRING, :name => 'msg'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class SurrogateQualification
      include ::Thrift::Struct, ::Thrift::Struct_Union
      R2 = 1
      YP = 2

      FIELDS = {
        R2 => {:type => ::Thrift::Types::DOUBLE, :name => 'r2'},
        YP => {:type => ::Thrift::Types::LIST, :name => 'yp', :element => {:type => ::Thrift::Types::DOUBLE}}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class SobolIndices
      include ::Thrift::Struct, ::Thrift::Struct_Union
      S1 = 1
      ST = 2

      FIELDS = {
        S1 => {:type => ::Thrift::Types::LIST, :name => 'S1', :element => {:type => ::Thrift::Types::DOUBLE}},
        ST => {:type => ::Thrift::Types::LIST, :name => 'ST', :element => {:type => ::Thrift::Types::DOUBLE}}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Distribution
      include ::Thrift::Struct, ::Thrift::Struct_Union
      NAME = 1
      KWARGS = 2

      FIELDS = {
        NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
        KWARGS => {:type => ::Thrift::Types::MAP, :name => 'kwargs', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::DOUBLE}}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class OptimizerResult
      include ::Thrift::Struct, ::Thrift::Struct_Union
      STATUS = 1
      X_SUGGESTED = 2
      X_BEST = 3
      Y_BEST = 4

      FIELDS = {
        STATUS => {:type => ::Thrift::Types::I64, :name => 'status'},
        X_SUGGESTED => {:type => ::Thrift::Types::LIST, :name => 'x_suggested', :element => {:type => ::Thrift::Types::DOUBLE}},
        X_BEST => {:type => ::Thrift::Types::LIST, :name => 'x_best', :element => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::DOUBLE}}, :optional => true},
        Y_BEST => {:type => ::Thrift::Types::LIST, :name => 'y_best', :element => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::DOUBLE}}, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ConstraintSpec
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TYPE = 1
      BOUND = 2

      FIELDS = {
        TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::WhatsOpt::Services::ConstraintType},
        BOUND => {:type => ::Thrift::Types::DOUBLE, :name => 'bound'}
      }

      def struct_fields; FIELDS; end

      def validate
        unless @type.nil? || ::WhatsOpt::Services::ConstraintType::VALID_VALUES.include?(@type)
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
        end
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Flimits
      include ::Thrift::Struct, ::Thrift::Struct_Union
      LOWER = 1
      UPPER = 2

      FIELDS = {
        LOWER => {:type => ::Thrift::Types::DOUBLE, :name => 'lower'},
        UPPER => {:type => ::Thrift::Types::DOUBLE, :name => 'upper'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Ilimits
      include ::Thrift::Struct, ::Thrift::Struct_Union
      LOWER = 1
      UPPER = 2

      FIELDS = {
        LOWER => {:type => ::Thrift::Types::I64, :name => 'lower'},
        UPPER => {:type => ::Thrift::Types::I64, :name => 'upper'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Xlimits < ::Thrift::Union
      include ::Thrift::Struct_Union
      class << self
        def flimits(val)
          Xlimits.new(:flimits, val)
        end

        def ilimits(val)
          Xlimits.new(:ilimits, val)
        end

        def olimits(val)
          Xlimits.new(:olimits, val)
        end

        def elimits(val)
          Xlimits.new(:elimits, val)
        end
      end

      FLIMITS = 1
      ILIMITS = 2
      OLIMITS = 3
      ELIMITS = 4

      FIELDS = {
        FLIMITS => {:type => ::Thrift::Types::STRUCT, :name => 'flimits', :class => ::WhatsOpt::Services::Flimits, :optional => true},
        ILIMITS => {:type => ::Thrift::Types::STRUCT, :name => 'ilimits', :class => ::WhatsOpt::Services::Ilimits, :optional => true},
        OLIMITS => {:type => ::Thrift::Types::LIST, :name => 'olimits', :element => {:type => ::Thrift::Types::DOUBLE}, :optional => true},
        ELIMITS => {:type => ::Thrift::Types::LIST, :name => 'elimits', :element => {:type => ::Thrift::Types::STRING}, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
      end

      ::Thrift::Union.generate_accessors self
    end

    class Xtype
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TYPE = 1
      LIMITS = 2

      FIELDS = {
        TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::WhatsOpt::Services::Type},
        LIMITS => {:type => ::Thrift::Types::STRUCT, :name => 'limits', :class => ::WhatsOpt::Services::Xlimits}
      }

      def struct_fields; FIELDS; end

      def validate
        unless @type.nil? || ::WhatsOpt::Services::Type::VALID_VALUES.include?(@type)
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
        end
      end

      ::Thrift::Struct.generate_accessors self
    end

    class HsicAnalysis
      include ::Thrift::Struct, ::Thrift::Struct_Union
      INDICES = 1
      R2 = 2
      PVPERM = 3
      PVAS = 4

      FIELDS = {
        INDICES => {:type => ::Thrift::Types::LIST, :name => 'indices', :element => {:type => ::Thrift::Types::DOUBLE}},
        R2 => {:type => ::Thrift::Types::LIST, :name => 'r2', :element => {:type => ::Thrift::Types::DOUBLE}},
        PVPERM => {:type => ::Thrift::Types::LIST, :name => 'pvperm', :element => {:type => ::Thrift::Types::DOUBLE}},
        PVAS => {:type => ::Thrift::Types::LIST, :name => 'pvas', :element => {:type => ::Thrift::Types::DOUBLE}}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

  end
end
