#
# Autogenerated by Thrift Compiler (0.22.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'

module WhatsOpt
  module Services
    module ConstraintType
      LESS = 0
      EQUAL = 1
      GREATER = 2
      VALUE_MAP = {0 => "LESS", 1 => "EQUAL", 2 => "GREATER"}
      VALID_VALUES = Set.new([LESS, EQUAL, GREATER]).freeze
    end

    module Type
      FLOAT = 0
      INT = 1
      ORD = 2
      ENUM = 3
      VALUE_MAP = {0 => "FLOAT", 1 => "INT", 2 => "ORD", 3 => "ENUM"}
      VALID_VALUES = Set.new([FLOAT, INT, ORD, ENUM]).freeze
    end

    class OptionValue < ::Thrift::Union; end

    class Distribution; end

    class ConstraintSpec; end

    class Flimits; end

    class Ilimits; end

    class Xlimits < ::Thrift::Union; end

    class Xtype; end

    class OptionValue < ::Thrift::Union
      include ::Thrift::Struct_Union
      class << self
        def integer(val)
          OptionValue.new(:integer, val)
        end

        def number(val)
          OptionValue.new(:number, val)
        end

        def vector(val)
          OptionValue.new(:vector, val)
        end

        def matrix(val)
          OptionValue.new(:matrix, val)
        end

        def str(val)
          OptionValue.new(:str, val)
        end

        def boolean(val)
          OptionValue.new(:boolean, val)
        end
      end

      INTEGER = 1
      NUMBER = 2
      VECTOR = 3
      MATRIX = 4
      STR = 5
      BOOLEAN = 6

      FIELDS = {
        INTEGER => {:type => ::Thrift::Types::I64, :name => 'integer', :optional => true},
        NUMBER => {:type => ::Thrift::Types::DOUBLE, :name => 'number', :optional => true},
        VECTOR => {:type => ::Thrift::Types::LIST, :name => 'vector', :element => {:type => ::Thrift::Types::DOUBLE}, :optional => true},
        MATRIX => {:type => ::Thrift::Types::LIST, :name => 'matrix', :element => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::DOUBLE}}, :optional => true},
        STR => {:type => ::Thrift::Types::STRING, :name => 'str', :optional => true},
        BOOLEAN => {:type => ::Thrift::Types::BOOL, :name => 'boolean', :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
      end

      ::Thrift::Union.generate_accessors self
    end

    class Distribution
      include ::Thrift::Struct, ::Thrift::Struct_Union
      NAME = 1
      KWARGS = 2

      FIELDS = {
        NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
        KWARGS => {:type => ::Thrift::Types::MAP, :name => 'kwargs', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::DOUBLE}}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ConstraintSpec
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TYPE = 1
      BOUND = 2

      FIELDS = {
        TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::WhatsOpt::Services::ConstraintType},
        BOUND => {:type => ::Thrift::Types::DOUBLE, :name => 'bound'}
      }

      def struct_fields; FIELDS; end

      def validate
        unless @type.nil? || ::WhatsOpt::Services::ConstraintType::VALID_VALUES.include?(@type)
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
        end
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Flimits
      include ::Thrift::Struct, ::Thrift::Struct_Union
      LOWER = 1
      UPPER = 2

      FIELDS = {
        LOWER => {:type => ::Thrift::Types::DOUBLE, :name => 'lower'},
        UPPER => {:type => ::Thrift::Types::DOUBLE, :name => 'upper'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Ilimits
      include ::Thrift::Struct, ::Thrift::Struct_Union
      LOWER = 1
      UPPER = 2

      FIELDS = {
        LOWER => {:type => ::Thrift::Types::I64, :name => 'lower'},
        UPPER => {:type => ::Thrift::Types::I64, :name => 'upper'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Xlimits < ::Thrift::Union
      include ::Thrift::Struct_Union
      class << self
        def flimits(val)
          Xlimits.new(:flimits, val)
        end

        def ilimits(val)
          Xlimits.new(:ilimits, val)
        end

        def olimits(val)
          Xlimits.new(:olimits, val)
        end

        def elimits(val)
          Xlimits.new(:elimits, val)
        end
      end

      FLIMITS = 1
      ILIMITS = 2
      OLIMITS = 3
      ELIMITS = 4

      FIELDS = {
        FLIMITS => {:type => ::Thrift::Types::STRUCT, :name => 'flimits', :class => ::WhatsOpt::Services::Flimits, :optional => true},
        ILIMITS => {:type => ::Thrift::Types::STRUCT, :name => 'ilimits', :class => ::WhatsOpt::Services::Ilimits, :optional => true},
        OLIMITS => {:type => ::Thrift::Types::LIST, :name => 'olimits', :element => {:type => ::Thrift::Types::DOUBLE}, :optional => true},
        ELIMITS => {:type => ::Thrift::Types::LIST, :name => 'elimits', :element => {:type => ::Thrift::Types::STRING}, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
      end

      ::Thrift::Union.generate_accessors self
    end

    class Xtype
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TYPE = 1
      LIMITS = 2

      FIELDS = {
        TYPE => {:type => ::Thrift::Types::I32, :name => 'type', :enum_class => ::WhatsOpt::Services::Type},
        LIMITS => {:type => ::Thrift::Types::STRUCT, :name => 'limits', :class => ::WhatsOpt::Services::Xlimits}
      }

      def struct_fields; FIELDS; end

      def validate
        unless @type.nil? || ::WhatsOpt::Services::Type::VALID_VALUES.include?(@type)
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field type!')
        end
      end

      ::Thrift::Struct.generate_accessors self
    end

  end
end
